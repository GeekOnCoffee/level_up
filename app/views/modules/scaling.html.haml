.content.module
  .page-header
    %h1 Performance and Scaling

  .row
    .col-lg-8
      %p Performance testing occupies an interesting space in web development. As developers, we tend to do both too much and not enough of this kind of testing. Too much in that we make half-baked assumptions about what parts of our code will be slow, and do silly amounts of work to "optimize" them. And then not enough, because the actual bottlenecks in our programs tend to go forgotten.
      %p In this performance lab, we're going to take a look at a real-ish Rails application. This application is built primarily using the default Rails generators, and has some common warts that you would expect to see on any Rails site. We'll move through a series of optimizations, quantifying each one as we move along. You should get into the habit of testing your assumptions around optimization, or you'll twist your codebase into contortions for no reason. This stuff isn't free -- you could be spending this time developing new features.
      %p Still, if you want to stand a chance of writing a Rails application that sees real usage in the real world, these kind of optimizations will eventually be necessary. Rails has a reputation of being slow, but it's not deserved, as we'll see.

      .page-header
        %h3 Detection and Your Environment
        %p There is really one main reason why our Rails apps don't get optimized properly: we aren't really the users. While we run our applications locally to develop and test them, we usually aren't the primary users of the app. Even when we do use them, we tend not to be "extreme" users of the app. Let's take a look at some ways that we can start to understand the pain that we're inflicting on our users and get a grip on what needs to be optimized.
        %p So, the first thing we're going to do is to move into a production-like environment so that we can observe performance characteristics when not running on a production system.
        = exercise_block_for "scaling", "remote" do |e|
          = e.question "Get off localhost. Deploy the application to some other environment. Heroku, a virtual machine, doesn't matter."
          = e.question "Seed the \"production\" and development databases and compare performance between the two. How different are they? What contributes to that difference?"
        %p Now that we can start to feel some of the pain, let's focus on how to diagnose performance problems. While you should start to see some of these issues on your own, as a developer you are still not well equipped as an "average" user. To get an idea of what problems your customers are facing, you should be using regular monitoring tools as part of your workflow
        %p There are several such tools, but we'll focus on just one for now. <a href='http://newrelic.com'>New Relic</a> is a popular monitoring tool that can keep track of your application performance for you. With their paid plans, you can also do extensive tracing of transactions and pages from your application.
        = exercise_block_for "scaling", "diagnose" do |e|
          = e.question "Sign up for a free NewRelic account. No need to provide payment credentials or anything here."
          = e.question "Install the NewRelic client in the app. Deploy with the client enabled, or at least run it in development mode."
          = e.question "If you're not a junior engineer, make sure your license key isn't checked into source control. C'mon, what are you thinking?"
        %p 
        = exercise_block_for "scaling", "premature" do |e|
          = e.question "Quantifying problems before trying to fix them."
        = exercise_block_for "scaling", "profile" do |e|
          = e.question "More realistic load profiles."

      .page-header
        %h3 Basic Refactoring
        %p Before we go writing new code or using obscure features to fix our codebase, let's cover some basic refactoring techniques that we can use to fix some performance issues. Most of these fixes aren't even specific to Rails or Ruby. Remember to write code to quantitatively test whether your optimizations are doing any real good.
        %a{href: "https://www.coffeepowered.net/2009/01/23/mass-inserting-data-in-rails-without-killing-your-performance"}
        = exercise_block_for "scaling", "import" do |e|
          = e.question "Scale seed data properly."
        = exercise_block_for "scaling", "loop_invariant" do |e|
          = e.question "Array inside a loop, string copies within a loop: COUNTRY_CODE_MAP.detect? { |k,v| [k.downcase, v.downcase].include? string.downcase }"
        = exercise_block_for "scaling", "wrong_work" do |e|
          = e.question "Move computation into the database"
        = exercise_block_for "scaling", "include" do |e|
          = e.question "Use || instead of .include? for small arrays"
        = exercise_block_for "scaling", "pluck" do |e|
          = e.question "Use .pluck and other useful library calls (delete_all versus destroy_all)"
        = exercise_block_for "scaling", "batches" do |e|
          = e.question "Move to batch processing, configure batch size"
        %p
          %a{href: "https://github.com/charliesome/charlie.bz/blob/master/posts/things-that-clear-rubys-method-cache.md"}
        = exercise_block_for "scaling", "method_cache" do |e|
          = e.question "Remove method cache clear by way of OpenStruct creation"
        = exercise_block_for "scaling", "slow_tests" do |e|
          = e.question "Slow unit tests, refactor to remove tons of extra data"
        = exercise_block_for "scaling", "scope" do |e|
          = e.question "Remove unnecessary default scope that sorts on an expensive key"
        = exercise_block_for "scaling", "all" do |e|
          = e.question "Switch from User.all"
        = exercise_block_for "scaling", "memoization" do |e|
          = e.question "Simple memoize"

      .page-header
        %h3 Rails Features
        %p Now that we've plucked some of the low hanging fruit, let's talk about Rails features that we can use to help us optimize our code. Rails has had a reputation for being slow for years now, and while you may need to consider alternatives if you reach Twitter-scale, almost any site can get reasonable performance out of Rails with a little forethought. Let's take a look at the toolbox you get for using Rails.
        = exercise_block_for "scaling", "n_plus_one" do |e|
          = e.question "Solve an n+1 SQL loading problem"
        = exercise_block_for "scaling", "cache_expiry" do |e|
          = e.question "Cache expiration keys and touch:true"
        = exercise_block_for "scaling", "chunk_caching" do |e|
          = e.question "Add page chunk caching"
        = exercise_block_for "scaling", "page_caching" do |e|
          = e.question "Add whole-page caching (move a dynamic block to JSON)"
        = exercise_block_for "scaling", "pagination" do |e|
          = e.question "Pagination?"
        = exercise_block_for "scaling", "serializers" do |e|
          = e.question "Move to http://github.com/dockyard/postgres_ext-serializers"

      .page-header
        %h3 Platform
        = exercise_block_for "scaling", "thread" do |e|
          = e.question "Fix a non-threadsafe issue and move to Rubinius?"
        = exercise_block_for "scaling", "redis" do |e|
          = e.question "Add redis, memoize some methods into redis"
        = exercise_block_for "scaling", "sidekiq" do |e|
          = e.question "Defer execution using Sidekiq"
        = exercise_block_for "scaling", "mongrel" do |e|
          = e.question "Switch to a pack of Mongrels?"
        = exercise_block_for "scaling", "cdn" do |e|
          = e.question "Serve assets from nginx"
        = exercise_block_for "scaling", "faraday" do |e|
          = e.question "Adding SOA-caching via Faraday"

    .col-lg-4.resources{role:'complementary'}
      .bs-component
        .panel.panel-basic
          = render partial: 'modules/scaling_resources'
